'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _request = require('./request');

var _request2 = _interopRequireDefault(_request);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * @private
 * If initialized with ``>1`` nodes, the driver will send successive
 * requests to different nodes in a round-robin fashion (this will be
 * customizable in the future).
 */

var Transport = function () {
    function Transport(nodes, timeout) {
        var _this = this;

        (0, _classCallCheck3.default)(this, Transport);

        this.connectionPool = [];
        this.timeout = timeout;
        // the maximum backoff time is 10 seconds
        this.maxBackoffTime = timeout ? timeout / 2 : 10000;
        nodes.forEach(function (node) {
            _this.connectionPool.push(new _request2.default(node));
        });
    }

    // Select the connection with the earliest backoff time, in case of a tie,
    // prefer the one with the smaller list index


    (0, _createClass3.default)(Transport, [{
        key: 'pickConnection',
        value: function pickConnection() {
            var connection = this.connectionPool[0];

            this.connectionPool.forEach(function (conn) {
                // 0 the lowest value is the time for Thu Jan 01 1970 01:00:00 GMT+0100 (CET)
                conn.backoffTime = conn.backoffTime ? conn.backoffTime : 0;
                connection = conn.backoffTime < connection.backoffTime ? conn : connection;
            });
            return connection;
        }
    }, {
        key: 'forwardRequest',
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(path, headers) {
                var response, connection, startTime, elapsed, errorObject;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                response = void 0;
                                connection = void 0;
                                // A new request will be executed until there is a valid response or timeout < 0

                            case 2:
                                if (!(this.timeout >= 0)) {
                                    _context.next = 22;
                                    break;
                                }

                                connection = this.pickConnection();
                                // Date in milliseconds
                                startTime = Date.now();
                                _context.prev = 5;
                                _context.next = 8;
                                return connection.request(path, headers, this.timeout, this.maxBackoffTime);

                            case 8:
                                response = _context.sent;
                                elapsed = Date.now() - startTime;

                                if (!(connection.backoffTime > 0 && this.timeout > 0)) {
                                    _context.next = 14;
                                    break;
                                }

                                this.timeout -= elapsed;
                                _context.next = 15;
                                break;

                            case 14:
                                return _context.abrupt('return', response);

                            case 15:
                                _context.next = 20;
                                break;

                            case 17:
                                _context.prev = 17;
                                _context.t0 = _context['catch'](5);
                                throw _context.t0;

                            case 20:
                                _context.next = 2;
                                break;

                            case 22:
                                errorObject = {
                                    message: 'TimeoutError'
                                };
                                throw errorObject;

                            case 24:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, this, [[5, 17]]);
            }));

            function forwardRequest(_x, _x2) {
                return _ref.apply(this, arguments);
            }

            return forwardRequest;
        }()
    }]);
    return Transport;
}(); // Copyright BigchainDB GmbH and BigchainDB contributors
// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)
// Code is Apache-2.0 and docs are CC-BY-4.0

exports.default = Transport;