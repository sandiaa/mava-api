'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _baseRequest = require('./baseRequest');

var _baseRequest2 = _interopRequireDefault(_baseRequest);

var _sanitize = require('./sanitize');

var _sanitize2 = _interopRequireDefault(_sanitize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright BigchainDB GmbH and BigchainDB contributors
// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)
// Code is Apache-2.0 and docs are CC-BY-4.0

var DEFAULT_REQUEST_CONFIG = {
    headers: {
        'Accept': 'application/json'
    }
};

var BACKOFF_DELAY = 500; // 0.5 seconds
var ERROR_FROM_SERVER = 'HTTP Error: Requested page not reachable';
/**
 * @private
 * Small wrapper around js-utility-belt's request that provides url resolving,
 * default settings, and response handling.
 */

var Request = function () {
    function Request(node) {
        (0, _classCallCheck3.default)(this, Request);

        this.node = node;
        this.backoffTime = null;
        this.retries = 0;
        this.connectionError = null;
    }

    (0, _createClass3.default)(Request, [{
        key: 'request',
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(urlPath, config, timeout, maxBackoffTime) {
                var _this = this;

                var requestConfig, apiUrl, backoffTimedelta, errorObject, requestTimeout;
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (urlPath) {
                                    _context2.next = 2;
                                    break;
                                }

                                return _context2.abrupt('return', Promise.reject(new Error('Request was not given a url.')));

                            case 2:
                                // Load default fetch configuration and remove any falsy query parameters
                                requestConfig = (0, _extends3.default)({}, this.node.headers, DEFAULT_REQUEST_CONFIG, config, {
                                    query: config.query && (0, _sanitize2.default)(config.query)
                                });
                                apiUrl = this.node.endpoint + urlPath;

                                if (requestConfig.jsonBody) {
                                    requestConfig.headers = (0, _extends3.default)({}, requestConfig.headers, {
                                        'Content-Type': 'application/json'
                                    });
                                }

                                // If connectionError occurs, a timestamp equal to now +
                                // `backoffTimedelta` is assigned to the object.
                                // Next time the function is called, it either
                                // waits till the timestamp is passed or raises `TimeoutError`.
                                // If `ConnectionError` occurs two or more times in a row,
                                // the retry count is incremented and the new timestamp is calculated
                                // as now + the `backoffTimedelta`
                                // The `backoffTimedelta` is the minimum between the default delay
                                // multiplied by two to the power of the
                                // number of retries or timeout/2 or 10. See Transport class for that
                                // If a request is successful, the backoff timestamp is removed,
                                // the retry count is back to zero.

                                backoffTimedelta = this.getBackoffTimedelta();

                                if (!(timeout != null && timeout < backoffTimedelta)) {
                                    _context2.next = 9;
                                    break;
                                }

                                errorObject = {
                                    message: 'TimeoutError'
                                };
                                throw errorObject;

                            case 9:
                                if (!(backoffTimedelta > 0)) {
                                    _context2.next = 12;
                                    break;
                                }

                                _context2.next = 12;
                                return Request.sleep(backoffTimedelta);

                            case 12:
                                requestTimeout = timeout ? timeout - backoffTimedelta : timeout;
                                return _context2.abrupt('return', (0, _baseRequest2.default)(apiUrl, requestConfig, requestTimeout).then(function () {
                                    var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(res) {
                                        return _regenerator2.default.wrap(function _callee$(_context) {
                                            while (1) {
                                                switch (_context.prev = _context.next) {
                                                    case 0:
                                                        _this.connectionError = null;
                                                        return _context.abrupt('return', res.json());

                                                    case 2:
                                                    case 'end':
                                                        return _context.stop();
                                                }
                                            }
                                        }, _callee, _this);
                                    }));

                                    return function (_x5) {
                                        return _ref2.apply(this, arguments);
                                    };
                                }()).catch(function (err) {
                                    // ConnectionError
                                    _this.connectionError = err;
                                }).finally(function () {
                                    _this.updateBackoffTime(maxBackoffTime);
                                }));

                            case 14:
                            case 'end':
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function request(_x, _x2, _x3, _x4) {
                return _ref.apply(this, arguments);
            }

            return request;
        }()
    }, {
        key: 'updateBackoffTime',
        value: function updateBackoffTime(maxBackoffTime) {
            if (!this.connectionError) {
                this.retries = 0;
                this.backoffTime = null;
            } else if (this.connectionError.message === ERROR_FROM_SERVER) {
                // If status is not a 2xx (based on Response.ok), throw error
                this.retries = 0;
                this.backoffTime = null;
                throw this.connectionError;
            } else {
                // Timeout or no connection could be stablished
                var backoffTimedelta = Math.min(BACKOFF_DELAY * Math.pow(2, this.retries), maxBackoffTime);
                this.backoffTime = Date.now() + backoffTimedelta;
                this.retries += 1;
                if (this.connectionError.message === 'TimeoutError') {
                    throw this.connectionError;
                }
            }
        }
    }, {
        key: 'getBackoffTimedelta',
        value: function getBackoffTimedelta() {
            if (!this.backoffTime) {
                return 0;
            }
            return this.backoffTime - Date.now();
        }
    }], [{
        key: 'sleep',
        value: function sleep(ms) {
            return new Promise(function (resolve) {
                return setTimeout(resolve, ms);
            });
        }
    }]);
    return Request;
}();

exports.default = Request;